/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package frontend;

import backend.ConnectionGraph;
import backend.WegfinderBack;
import graphklassen.*;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Container;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import javax.swing.ImageIcon;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import javax.imageio.ImageIO;
import javax.print.Doc;
import javax.print.DocFlavor;
import javax.print.DocPrintJob;
import javax.print.PrintException;
import javax.print.PrintService;
import javax.print.PrintServiceLookup;
import javax.print.SimpleDoc;
import javax.print.attribute.HashPrintRequestAttributeSet;
import javax.print.attribute.PrintRequestAttributeSet;
import static javax.print.attribute.standard.Chromaticity.COLOR;
import javax.swing.AbstractAction;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.KeyStroke;
import listenklassen.*;

/**
 *
 * @author Dominik Onyszkiewicz
 */
public class GroundPlanPanel extends javax.swing.JPanel {

    private UserInterface ui;
    private WegfinderBack backend;
    private ConnectionGraph schoolGraph;
    private List<GraphNode> path;
    private final Image gpImage;
    private int bgSideLength, standardSideLength;
    private double diff;
    private int xOffset, yOffset, initialYOffset;
    private Container parent;
    protected Point highlightPos;
    private int highlightRadius;
    private Point lastClickPos;
    private long clickTime;
    
    private boolean debug;
    private JLabel[] nodeNames;
    
    
    /**
     * Creates new form GroundPlanPanel
     * @param content Parent 'Content' Object
     */
    public GroundPlanPanel(Container parent, int initialYOffset) {
        initComponents();
        
        ui = UserInterface.getUI();
        backend = WegfinderBack.getBackend();
        
        gpImage = new ImageIcon(getClass().getResource("EGKerpen_Grundriss_Neu.png")).getImage();
        standardSideLength = gpImage.getWidth(this);
        
        schoolGraph = WegfinderBack.getSchoolGraph();
        path = new List<>();
        
        this.parent = parent;
        this.initialYOffset = initialYOffset;
        
        highlightPos = null;
        highlightRadius = 18;
        
        lastClickPos = new Point(0, 0);
        clickTime = 0;
        
        // debugging
        debug = false;
        nodeNames = new JLabel[0];
        
        // Switching debug mode on and off with Ctrl + D
        this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_D, KeyEvent.CTRL_MASK), "debug");
        this.getActionMap().put("debug", new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                switchDebugMode();
            }
        });
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        Point pos = evt.getPoint();
        String room = getRoomInformations(pos);
        long time = System.currentTimeMillis();
        if(time - clickTime < 300 && pos.x == lastClickPos.x && pos.y == lastClickPos.y) {
            backend.drawPath("Foyer", room);
            // TODO: Fix node position of room 284
        }
        lastClickPos = pos;
        clickTime = time;
    }//GEN-LAST:event_formMouseClicked

    /**
     * Draws the path from 'start' to 'dest' on the background image.
     * @param start name of the start node
     * @param dest name of the destination node
     */
    public void drawPath(String start, String dest){
        path = schoolGraph.getPath(start, dest);
        
        
        // For debugging use only:
        // Writes all nodes of the path into the console
        path.toFirst();
        while(path.hasAccess()){
            System.out.println(path.getObject().getName());
            path.next();
        }
        path.toFirst();
        
        repaint();
    }
    
    /**
     * Prints the content of the panel with the generated path.
     */
    public void print() {
        // Add the start and destination node names to the panel before printing
        path.toFirst();
        JLabel start = new JLabel("Von: " + path.getObject().getName());
        path.toLast();
        JLabel dest = new JLabel("Nach: " + path.getObject().getName());
        start.setBounds(5, 0, 100, 20);
        dest.setBounds(5, 18, 100, 20);
        this.add(start);
        this.add(dest);
        
        
        BufferedImage img = new BufferedImage(this.getWidth(), this.getHeight(), BufferedImage.TYPE_INT_RGB);
        paint(img.createGraphics());
        
        // Modify this String to alter the location to which the image is saved.
        String filename = ".\\image.jpg";
        
        try {
            ImageIO.write(img, "jpg", new File(filename));
        } catch(IOException e){
            e.printStackTrace();
        }
        
        try {
            
            FileInputStream textStream = new FileInputStream(filename);
            
            DocFlavor formatSTREAM = DocFlavor.INPUT_STREAM.JPEG;
            PrintService service = PrintServiceLookup.lookupDefaultPrintService();
            DocPrintJob job = service.createPrintJob();
            Doc doc = new SimpleDoc(textStream, formatSTREAM, null);
            PrintRequestAttributeSet color = new HashPrintRequestAttributeSet();
            color.add(COLOR);
            job.print(doc, color);
 
        } catch (FileNotFoundException | PrintException e) {
            e.printStackTrace();
        }
        
        // remove the labels afterwards
        this.remove(start);
        this.remove(dest);
    }
    
    /**
     * Paints the Panel with the background and the path 
     * considering the window scale.(Debugmode off)
     * Paints all nodes with the associated names.(Debugmode on)
     * @param g 
     */
    @Override
    public void paintComponent(Graphics g){
        super.paintComponent(g);
        // Update all offsets and scale the panel with the window size
        updateOffsets();
        this.setBounds(xOffset, yOffset, bgSideLength, bgSideLength);
        g.drawImage(gpImage, 0, 0, bgSideLength, bgSideLength,this);
        
        Graphics2D g2d = (Graphics2D) g;
        g2d.setStroke(new BasicStroke((int) Math.round(3 * diff)));
        
        int pointSize = (int) Math.round(5 * diff);
        int offset = (int) Math.round(pointSize / 2);
        
        if(!debug) {
            // Draw the path if one exists and debugging is disabled
            if(!path.isEmpty()) {
                g.setColor(Color.red);
                GraphNode n1, n2;
                
                path.toFirst();

                n1 = path.getObject();

                path.next();

                while(path.hasAccess()){
                    n2 = path.getObject();

                    if(!(n1.getName().charAt(0) == 'T' && n2.getName().charAt(0) == 'T')){
                        g.fillRect((int) (diff * n1.getX()) - offset, (int) (diff * n1.getY()) - offset, pointSize, pointSize);
                        g2d.drawLine((int) (diff * n1.getX()), (int) (diff * n1.getY()), 
                                (int) (diff * n2.getX()), (int) (diff * n2.getY()));
                    }

                    n1 = n2;
                    path.next();
                }

                g.setColor(Color.green);

                path.toFirst();
                g.fillRect((int) (diff * path.getObject().getX()) - offset, 
                        (int) (diff * path.getObject().getY()) - offset, pointSize, pointSize);
                
                path.toLast();
                g.fillRect((int) (diff * path.getObject().getX()) - offset, 
                        (int) (diff * path.getObject().getY()) - offset, pointSize, pointSize);
            }
            
            int radius = (int) Math.round(highlightRadius * diff);
            if(highlightPos != null) {
                g.setColor(Color.RED);
                g.drawOval((int) Math.round(highlightPos.getX() * diff - radius), (int) Math.round(highlightPos.getY() * diff - radius), radius * 2, radius * 2);
                g.setColor(new Color(255, 0, 0, 70));
                g.fillOval((int) Math.round(highlightPos.getX() * diff - radius), (int) Math.round(highlightPos.getY() * diff - radius), radius * 2, radius * 2);
            }
        }
        else {
            // Draw all nodes and the associated names if debugging is enabled
            List<GraphNode> nodes = schoolGraph.getNodes();
            nodes.toFirst();
            // determine the amount of nodes in the whole graph
            int nodesCount = 0;
            while(nodes.hasAccess()) {
                nodesCount++;
                nodes.next();
            }
            // Create new array for the nodes names if it does not already exist.
            // Otherwise make all existing node names visible.
            if(nodeNames.length == 0) {
                nodeNames = new JLabel[nodesCount];
            }
            else {
                for(JLabel label : nodeNames) {
                    label.setVisible(true);
                }
            }
            nodes.toFirst();
            int counter = 0;
            GraphNode node;
            // Draw every node with the name next to it
            g.setColor(Color.RED);
            while(nodes.hasAccess()) {
                node = nodes.getObject();
                g.fillRect((int) (diff * node.getX())-offset, (int) (diff * node.getY())-offset, pointSize, pointSize);
                if(nodeNames[counter] == null) {
                    nodeNames[counter] = new JLabel(node.getName());
                    nodeNames[counter].setFont(new Font(nodeNames[counter].getFont().getName(), Font.PLAIN, 8));
                    nodeNames[counter].setBounds((int) (diff * node.getX()),(int) (diff *  node.getY()), 100, 8);
                    this.add(nodeNames[counter]);
                }
                else {
                    nodeNames[counter].setLocation((int) (diff * node.getX()),(int) (diff *  node.getY()));
                }
                counter++;
                nodes.next();
            }
        }
    }
    
    /**
     * Updates the side length of the panel/background and sets the offsets
     * depending on the window scale.
     */
    private void updateOffsets() {
        bgSideLength = Math.min(parent.getHeight(), parent.getWidth());
        xOffset = (parent.getWidth() - bgSideLength) / 2;
        yOffset = 0;
        diff = (double) bgSideLength / standardSideLength;
        ui = UserInterface.getUI();
        if(ui != null)
            ui.updateInformations();
    }
    
    /**
     * Switches the debug mode on and off depending on the previous state.
     */
    private void switchDebugMode() {
        if(debug == false) {
            System.out.println("Debug Mode enabled");
            debug = true;
            repaint();
        }
        else {
            System.out.println("Debug Mode disabled");
            debug = false;
            for(JLabel label : nodeNames) {
                label.setVisible(false);
            }
        }
    }
    
    /**
     * Returns the value by which the panel is scales down or up.
     * @return 
     */
    public double getScale() {
        return diff;
    }
    
    /**
     * Returns the initial side length of the ground plan panel
     * @return 
     */
    public int getStandardSideLength() {
        return standardSideLength;
    }
    
    /**
     * Returns the current side length of the ground plan
     * @return 
     */
    public int getSideLength() {
        return bgSideLength;
    }
    
    /**
     * Sets the position of the highlight circle
     */
    public void setHighlightPosition(Point newPos) {
        highlightPos = newPos;
    }
    
    /**
     * Prints the room informations into the user interface and returns the found room
     */
    public String getRoomInformations(Point pos) {
        String room = backend.getClosestRoom(new Point((int) Math.round(pos.getX() * (1/diff)), (int) Math.round(pos.getY() * (1/diff))));
        String[] teachers = backend.getTeachersInRoom(room);
        String teacherList = "";
        for(String t : teachers) {
            teacherList += " " + t + " &";
        }
        if(teachers.length > 0)
            teacherList = teacherList.substring(0, teacherList.length() - 1);
        ui.updateRoomInformations(room, teacherList);
        return room;
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
